= TMForum API Developer's Handbook Part 3, The API Development Loop
TM Forum Specification
Revision
:Revision: 0.2.0
:Date: 17-Apr-2025
:IPR-Mode: RAND
:TMF-Number: TODO
:Status: DRAFT
:Release-Status: Pre-production
:url-repo: https://github.com/tmforum-rand/ig1353-api-developers-guide
:doctype: book
:toc: 
 
== Executive Summary

This “How To” document set provides onboarding instructions and a user-guide for the TMForum Open-API development tools. The document is organized in multiple parts as follows:

[options=header]
|===
|Document Part |Summary

|*Part One: Initial Onboarding* |Prerequisites/Good To Know, First-Time Onboarding
|*Part Two: Starting a New API* |API Inception, API Profile, Getting an API Number
|*Part Three: The API Development Loop* |Admin: JIRA issues, Git issues and Branching, API Tools, How To Deep-Dives
|*Part Four: Advanced API Development* |ASyncAPI Specifications, How to make a DCS API, How to make a Composite API
|===


This part (Part Three) of the document provides an overview of the API development process, the inputs expected by the API author and the use of the tools to generate the necessary documents.

:sectnums:
== Managing Our Work

The TMForum uses a number of online collaboration tools to manage member's work across multiple companies and timezones. This includes weekly meetings, evolution of the API design patterns, API development progress and technical backlogs.

=== Tracking API Asset Production

* Use of JIRA, dashboards, EPICs

=== Technical JIRAs: The API Backlog

* Use of the "Component" attribute
* Reviewed weekly: Only to get consensus on a direction
* Making a report with JQL
* Attaching the technical backlog to the API EPIC?

=== Git Issues: The Tooling and CI/CD Backlog

* Tooling is more code-centric, so more amenable to direct Git references and Git issues
* Reviewed weekly

== The Production Process

Maybe this is just a sumamry table or a flow diagram:

* OAS Specification Generation
* PlantUML Diagram Generation
* Conformance Profile Generation
* CTK Generation
* RI/Sample Code Generation
* The Publication Process

== How To

=== Creating a CodeSpace

Codespace (https://docs.github.com/en/codespaces/overview) is a development environment that is spun-up on request and hosted on your behalf in the Azure cloud by GitHub. This mitigates the technical problems caused by members having different in-house development environments, configurations, language/tool versions, and restrictive corporate firewalls. 

The TMForum pay for this hosting, and boundaries are set on how much RAM and CPU resource is allocated and how long the instance will remain when unattended. The codespace is created from an Ubuntu Linux image that includes popular languages and tools by default.

image::images/part3-codespace.png[Codespaces,1440,1030,align="center",link=https://docs.github.com/en/codespaces/overview,window=_blank]

WARNING: If you create a codespace and work on files locally within it - *and then leave it unattended for more than a few days*, Azure will delete the instance and any local work within it will be lost. Your GitHub registered email address will recieve warning emails from <noreply@github.com> as this deadline approaches.
Always remember to check your work back into your branch before you leave, to avoid any loss.

*To create a Codespace*:

. Having logged into GitHub.com with your TMForum registered identity, navigate to the v5 API repository: https://github.com/tmforum-rand/OAS_Open_API_And_Data_Model

image::images/part3-repo.png[Repository,762,116,align="center",link=https://github.com/tmforum-rand/OAS_Open_API_And_Data_Model,window=_blank]

[start=2]
. The left hand drop-down in the screenshot above indicates your current branch (shown as `v5.0.0-dev`). Click this and select the appropriate branch for your API work.
. Now click the green "*<> Code*" button to the right. This will list any active codespaces that you may have, and allow you to create a new codespace on this current branch, by selecting the "+" button:

image::images/part3-codespace-create.png[Codespace,685,370,align="center",link=https://github.com/tmforum-rand/OAS_Open_API_And_Data_Model,window=_blank]

WARNING: Do make sure you are in the *right repository*, and the *right branch* before doing this - to ensure that GitHub spins up the right configuration for you.

[start=4]
. The codespace will request permissions related to spinning-up the Azure instance. Hit "*Authorize and continue*":

image::images/part3-codespace-authorize.png[Codespace,550,367,align="center",link=https://github.com/codespaces/allow_permissions,window=_blank]

[start=5]
. The codespace will now start up, which may take a minute to produce the initial Microsoft Code IDE within your browser. It will take a further few minutes to run up a docker instance from the terminal window at the bottom. This will finish when the following popup appears in the bottom-right of the browser:

image::images/part3-codespace-app-running.png[Codespace,456,115,align="center",link=https://github.com/codespaces/allow_permissions,window=_blank]

This application presents a simplified menu-driven front-end to the API tooling. Hit "*Open in Browser*" to see this appear in another tab - but you can ignore it for now, we will get back to it later.

If you have ever closed this tab and need to recreate it, click on the *PORTS* tab at the bottom of the main IDE window. Here you should see a single *Port*: 3000 line with column titles of *Forwarded Address*, *Running Process*, *Visibility* and *Origin*. Hover your mouse over the URL under *Forwarded Address* and you should see a small globe icon (highlighted in the circle below):

image::images/part3-codespace-port.png[Codespace,900,108,align="center",link=https://github.com/codespaces/allow_permissions,window=_blank]

If you click on this globe icon, the Web UI tab should be recreated.

*Back in the main IDE tab*: If you use Microsoft's Visual Studio Code IDE (https://code.visualstudio.com/), this will be a familiar layout, but presented through a web browser to an instance running in the Azure cloud, and looking at the TMForum v5 API repository. You can browse and modify files, and changes will be tracked for you to stage and commit from within the IDE back into this Git repository.

This link (https://docs.github.com/en/codespaces/getting-started/quickstart) describes the basics of using Codespaces, including source control and extensions.

=== Rules File Deep Dive

The TMF API rules file, along with JSON schema files - form the main areas of influence in the construction of a TMF API. Your main activity will be in crafting this rules file together with the associated JSON-Schema files to ensure that the naming and description of entities, properties, operations, notifications and overall structure "hang together" to describe your intensions in agreement with the TMForum API Design Guidelines.

The rules file is a YAML file (https://en.wikipedia.org/wiki/YAML), written in a Domain-Specific Language invented within the TMForum. Its purpose is to describe the high-level structure of the generated OAS file, and it is the main input to the TMF OAS generator.

The high-level structure of a simple rules file is shown below. This describes:

- An API called `MyAPI` (highlighted)
- With a single resource called `MyResource`  (highlighted)
- This resource has four required operations: `GET`, `PATCH`, `POST` and `DELETE`
- The `PATCH` operation does not allow `id`, `href`, `@type`, `@baseType` or `@schemaLocation` to be modified
- The `POST` operation mandates the `name` attribute
- The API can emit 3 notification types: `create`, `change` and `delete`

[plantuml,json,svg,align="center"]
----
include::images/rules-structure.puml[]
----

==== *API Meta Data*
The beginning  of the API rules file - describing the API metadata looks like this:
[source, yaml]
----
rulesVersion: 1.0.0                                         <1>
api:
  name:        MyAPI                                        <2>
  shortName:   MyAPI                                        <3>
  description: MyAPI description                            <4>
  tmfId:       TMFxxx                                       <5>
  hostUrl:     'https://serverRoot/tmf-api/MyAPI/v5/'       <6>
  version:     5.0.0                                        <7>
----
<1> This is the *version of the rules file format itself* - not of the API under construction. It is used by the OAS generator to warn of any outdated syntax, and will change very infrequently
<2> This is the name of your API. It will appear in the OAS file in the `info.title` attribute.
<3> [TODO] shortName
<4> This is the description of your API. It will appear in the OAS file in the `info.description` attribute. Try to keep this description fairly concise, avoid using formatting tags (as the text may appear in many formats: HTML, PDF and OAS rendering). Avoid use of special non-ASCII characters (such as copyright, trademark symbols) as these can also trip-up later parsing.
<5> This is the identity allocated by the TMForum to this API - typically in the form "TMFxxx" - where "xxx" is a three digit number. It has no direct translation into the OAS file, but will be used by the tooling in generation.
<6> The `hostUrl` translates into the `servers.url` attribute of the OAS file. Note that previous TMF-v4 swagger rules files used a `basePath` attribute which is ignored in OAS file generation.
<7> This is the version of your TMForum API. It follows the SemVer (https://semver.org/) versioning format: *<major>.<minor>.<patch>*. This value appears in the OAS file as attribute: `info.version`.

WARNING: New API development is typically started by copying and pasting an existing, working rules file from another API directory. While this is fine, and encouraged - do take the time to go through the above line-by-line to ensure that you have updated the values to reflect your new API.
Old API values are unlikely to throw tooling errors and will need to be caught by human review. If you take this review time up-front, it will prevent problems permeating the OAS file, User Guide and other published artifacts.

==== *API Resources, Operations and Notifications*

The remaining section of the rules file describes the resources of your API and the operations that you are allowing on them. The high-level structure looks like this:
[source, yaml]
----
resources:                                                                        <1>
 - name: <ResourceName>                                                           <2>
   schema: schemas/Tmf/<Domain>/<Resource>.schema.json#/definitions/<Resource>    <3>
   examples:
    - file: ./documentation/resource-samples/<Resource>.example.json              <4>
   supportedHttpMethods:                                                          <5>
     GET:
       required: true                                                             <6>
     POST:
       required: true
       requiredParameters:                                                        <7>
        - description
       parameterRestrictions:                                                     <8>
        - id
        - href
        - status
    notifications:                                                                <9>
     - name: create
       schema: schemas/Tmf/<Domain>/Event/ResourceNameCreateEvent.schema.json#/definitions/ResourceNameCreateEvent
----
<1> In the above rules file section, we are describing a single resource (or "endpoint") in our API called `ResourceName`. In reality your API might have a number of resources exposed, in which case everything from (2) onwards would be repeated for each one.
<2> This is the name of our resource being exposed. It will appear in the OAS file under the `paths` property as `/ResourceName`.
<3> Each resource needs to have a single canonical schema, from which all variations are based (see later). This will sit in the `/schemas/Tmf/<Domain>` directory - where `<Domain>` is decided based on how your resources fits within the TMForum Information Model high-level domains (such as *Product*, *Service*, *Resource*, *EngagedParty*, *Common* - etc). This is likely to have been worked out during your API Inception phase by agreement with the TMForum.
<4> Each main resource will have a full example laid out in the User Guide to help provide a context for the API developer who will be using this API.
<5> The `supportedHttpMethods` node provides some combination of the operations that you are allowing on your resource: *GET*, *POST*, *PATCH* and *DELETE*.
<6> For each operation, you can state whether this is required in every implementation of this API. For example, you might decide that a Trouble Ticket API does not make sense without the ability to at least *GET* one or more Trouble Tickets from a ticketing server implementation. In which case, you would state `required: true`. This has no direct translation to the generated OAS file, but the  operation will be mentioned as required in the user guide, and it will cause the TMForum Conformance Test Kit (CTK) to insist that this operation exists and is tested - in order to gain TMForum _conformance_ to this API.
<7> For some operations (POST, PATCH), it can make sense to insist that certain properties are present in the submitted payload from the client. You might decide that an entity MUST at least have a _name_, _description_, _value_ or some combination - for it to make sense. In which case, you would list these properties under `requiredParameters`.
<8> Conversely, you can also insist that certain properties from your canonical resource are *not* submitted by the client with POST-ing a payload. For example it is typically for the producer to decide on properties like *status* or *creationDate*. You would list these under `parameterRestrictions`.
<9> Finally, the API implementation might choose to publish events when significant state transitions occur in its implementation. For example, Orders will typically move through a number of states (such as _acknowledged_, _inProgress_, _failed_, _done_) while processing, and other clients might chose to subscribe an interest in these state changes.

The following operations may suggest these event notifications:
[options=header]
|===
|Operation |Typical Event Notifications
|GET | _none_
|POST | createEvent, statusChangeEvent, 
|PATCH | attributeValueChangeEvent
|DELETE | deleteEvent

|===

NOTE: There are many opportunities to reference example files for the full resource and operation requests and responses. *These are all optional to the generation of the OAS file itself*. While they will be needed for the full publication of the API, its user guide and CTK - we would recommend focussing on the OAS construction and approval before working on the examples, as changes to the structure and schemas of the API will cause a lot of rework to these examples.

==== *JSON-Schemas*

The API rules file implicitly makes references to a number of JSON-Schema files. Each resource named under the `resources:` section above as well as each event type named under the `notifications:` section will cause the OAS generator to search in the schema repository (`OAS_Open_API_And_Data_Model/tree/<YourBranch>/schemas`) for a JSON-Schema file fitting the format: `<MyResource>.schema.json`. In parsing _that_ JSON-Schema file, it will follow any `$ref` references to other JSON-Schema files, each defining a JSON object type and representing a business entity, until it has achieved a transitive-closure of all dependent schemas. This dependency graph will then form the `components.schemas` section of the resultant OAS file, so that all references can be resolved within the API specification.

*Schema Repository Structure*

The schema files defining the business entities that build up the API's resources are placed in the schema repository with the "*schemas*" directory as its root.

Within that structure, schemas of TMF defined entities are placed in the "*Tmf*" subdirectory and further in the subdirectory named according to the TMForum Information Model ("_SID_") domain *<Domain>* to which the entity belongs. Do take care when creating new entities to consider the right domain to place your JSON-Schema file.

Following the above pattern for schema files for resources, the schema file defining the entity *<Entity>* is named according to the pattern `<Entity>.schema.json`.

A schema file defining for an *<Entity>* an event *<Event>* is named `<Entity><Event>.schema.json`, and its payload is defined by a file `<Entity><Event>Payload.schema.json`. Both these kinds of files are placed in the "*Event*" subdirectory.

Schema files for entities of a given *<DCS>* (Domain Context Specialization) are located in subdirectories named "*DCS*", with a further subdirectory for each DCS, and the analogue sub-structure as for non-DCS TMF classes, including "*Event*" folders.

The resulting directory structure is as follows:

image::images/part3-schema-directory-structure.svg[layout of schema directory structure]

*Schema File Structure*

A cut down TMForum JSON-Schema file for a fictitious `Document` entity looks like this:
[source, json]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",                            <1>
  "$id": "Document.schema.json",                                                   <2>
  "title": "Document",                                                             <3>
  "definitions": {
    "Document": {                                                                  <4>
      "$id": "#Document",                                                          <5>
      "type": "object",
      "description": "Document is a tangible output from an activity",             <6>
      "properties": {                                                              <7>
        "name": {                                                                  <8>
          "type": "string",
          "description": "A string used to give a name to the document"
        },
        "size": {                                                                  <9>
          "type": "integer",
          "description": "The size of the Document"
        },
        "isEncrypted": {                                                           <10>
          "type": "boolean",
          "description": "An example for a boolean attribute"
        },
        "creationDate": {                                                          <11>
          "type": "string",
          "format": "date-time",
          "examples": [                                                            <12>
            "2025-04-16T00:00:00Z"
          ],
          "description": "The date and time when the document was created"
        },
        "validFor" : {                                                             <13>
          "$ref": "../Common/TimePeriod.schema.json#/definitions/TimePeriod",      <14>
          "description": "The period of time during which this Document is valid"  <15>
        },
        "characteristic": {                                                        <16>
          "type": "array",
          "items": {
            "$ref": "../Common/Characteristic.schema.json#/definitions/Characteristic"
          }
        }
      },
      "allOf": [                                                                   <17>
        {
          "$ref": "../Common/Entity.schema.json#/definitions/Entity"
        }
      ],
      "required": [ "name" ]                                                       <18>
    }
  }
}
----

Representing the name of the entity as <Entity>, the elements of the schema are:

<1> This is the version of JSON-Schema grammar that is being followed.
+
Fixed value, no [Entity] dependence.
Note that we are using https://json-schema.org/draft-07[Draft-07 of JSON Schema].

<2> This is using the filename of the JSON-Schema file as the unique $id of this schema.
+
MUST fit the pattern `[Entity].schema.json`.

<3> This is the JSON-Schema name of the business entity.
+
MUST fit the pattern `[Entity]`.

<4> This is opening the schema definition for this entity.
+
MUST fit the pattern `[Entity]`.
+
Note that this name together with its location within the schema is used in `$ref` references to this entity as target of the JSON Pointer, i.e. as `/definitions/[Entity]`.

<5> This is using the entity name of the JSON-Schema as the unique $id of this definition
+
MUST fit the pattern `#[Entity]`.
+
<6> This is the description of this business entity.
+
This description is copied into the API Specification (OAS file) and the API User Guide.
+
Try to be concise, and imagine this text appearing as a "tooltip" in an IDE. Note also that it appears in all APIs that directly or indirectly refer to this entity, so it should explain the entity without referring to the context of the rules file or schema file referring to it.

<7> The `properties` node contains the list of attributes and relationships associated with this entity definition.

<8> This `name` is a simple string attribute with no further restriction. Its description - as that of all attributes - is copied into the API Specification (OAS file) and the API User Guide and is used for display by tools like IDEs.
+
More specific definitions can be achieved by adding a `format`, e.g. `uri`, `uri-reference` and similar.
+
The values of string attributes can be further restricted by adding any of `minLength`, `maxLength`, `pattern` (a regular expression), `enum` (with a list of allowed values).

<9> Numeric attribute definitions can be typed as `integer` or `number`.
+
The `format` keyword can be used to define an `integer` more specific as `int32` or `int64`, and a `number` as `float` or `double`.
+
Further restrictions on numeric values can be `minimum`, `exclusiveMinimum`, `maximum`, `exclusiveMinimum`, `enum` (with a list of allowed values).

<10> Boolean attributes can take on the values `true` and `false`.

<11> Date and time attributes are modelled as type `string` with a `format`, possible values are `date`, `time` and `date-time`.

<12> A list of example values for an attribute can be provided.
+
Note that although JSON Schema supports an array of examples, Open API Specification only supports a single valued "example" element; thus only the first of the provided example values is copied to the OAS file.

<13> A composite sub-entity defined in another JSON Schema file.

<14> The reference to the JSON Schema file defining the sub-entity.
+
See below for the pattern defining the format of references.

<15> The description of the sub-entity in context of this entity.
+
Note that the according to the OpenAPI Specification, any sibling to a `$ref` reference shall be ignored. Tools like the https://editor.swagger.io/[swagger editor] will complain about this description, and use only the description coming from the referred schema.
+
Nevertheless, the TMF tooling copies this description into the API Specification (OAS file) and the API User Guide.

<16> This `characteristic` is a collection of _things of type Characteristic_, where the _Characteristic_ entity is itself defined in its own JSON-Schema file, being referenced (`$ref`) here. Collections are modelled as ordered `array` (thus having an array-index) of `items`.
+
Note that there must be \#/definitions anchor to the ref location as in this example : "$ref": "../Common/Characteristic.schema.json#/definitions/Characteristic"
+
Collections can further be restricted by `minItems`, `maxItems`, `uniqueItems`.

<17> Many TMForum "managed entities" typically include _all of_ the properties of the `Entity` schema. This makes them `Addressable` (having an `id` and `href`) and Extensible (having `@type`, `@baseType` and `@schemaLocation`). Other "base" entities can also be used to realize more "specialized" entities.

<18> The `required` section is an opportunity to list which of the above properties are "required" as a minimum to establish the main entity. In the above example you could say that a Document _is not a Document_ unless it at least has a `name` property.

<19> In some cases (see the following example), a schema is defined as a _one of_ choice between several alternative structures.

An example of a TMForum JSON-Schema modelling a choice looks like this:
[source, json]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "DocumentRefOrValue.schema.json",
  "title": "DocumentRefOrValue",
  "definitions": {
    "DocumentRefOrValue": {
      "$id": "#DocumentRefOrValue",
      "type": "object",
      "description": "A Document provided by reference or by value",
      "oneOf": [                                                                   <19>
        {
          "$ref": "../Common/Document.schema.json#/definitions/Document"
        },
        {
          "$ref": "../Common/DocumentRef.schema.json#/definitions/DocumentRef"
        }
      ]
    }
  }
}
----

*Format of References*

References JSON Schema file containing entity definitions exist in the API Rules Files as well as in the JSON Schema files, and by the TMF tooling are resolved recursively to generate the API's OAS file. TMF OpenAPIs apply the https://spec.openapis.org/oas/v3.0.1[OpenAPI Specification 3.0.1], so that the details of that OAS version must be considered.

For OAS 3.0, reference resolution is accomplished as defined by the https://datatracker.ietf.org/doc/html/draft-pbryan-zyp-json-ref-03[JSON Reference] specification and not by the JSON Schema specification.

The "$ref" string value contains a https://datatracker.ietf.org/doc/html/rfc3986#section-4.1[URI-reference], which identifies the location of the JSON value being referenced.

Within the TMF OpenAPI repository, only https://datatracker.ietf.org/doc/html/rfc3986#section-4.2[Relative References] of type "no-scheme" are used. It consists of a relative _path part_, i.e. a sequence of path segments separated by, but not starting with a slash ("/") character, followed by a hash ("#") character as separater and a _fragment part_.

_Path-Part_

In the _API Rules files_, the reference to a resource's JSON Schema file is relative to the root of the OpenAPI repository (`OAS_Open_API_And_Data_Model/tree/<YourBranch>`). Following the above defined Schema Repository Structure, its path part begins with `schema/Tmf/<Domain>`, possibly followed by `DCS`, specific `<DCS>` and/or `Event` segments, and the schema file name `<Entity>.schema.json`, resulting in any of the following alternatives:

* References to a standard <Entity> or related <Event> schema file:

  schema/Tmf/<Domain>/<Entity>.schema.json
  schema/Tmf/<Domain>/Event/<Entity><Event>.schema.json

* For DCS schemas shared by several DCSs:

  schema/Tmf/<Domain>/DCS/<Entity>.schema.json
  schema/Tmf/<Domain>/DCS/Event/<Entity><Event>.schema.json

* For schemas of a specific <DCS>:

  schema/Tmf/<Domain>/DCS/<DCS>/<Entity>.schema.json
  schema/Tmf/<Domain>/DCS/<DCS>/Event/<Entity><Event>.schema.json

Note that event payload schemas are only referred by their respective event schema.

In the _JSON Schema files_ within the schema repository, references to another JSON Schema file is relative to the referring schema file. If necessary to navigate into adjacent or parent locations of the schema repository, the path part can start with the double-dot-segment "..". Any single-dot (".") segment is ignored.

Examples:

* References from an entity schema file to a target entity schema file of the same `<Domain>`:

  <Entity>.schema.json

* References from an entity schema file to a target schemes of a different `<Domain>` (can also be used for references in the same domain):

  ../<Domain>/<Entity>.schema.json

* References from an event schema file to its payload schema file (always located in the same directory):

  <Entity><Event>Payload.schema.json

* References from an event payload schema file to its entity schema file:

  ../<Entity>.schema.json

* and similar references from a DCS schema file to some other schema file.
+
Note that DCS schemas are not referred from non-DCS schema files,
and schema files of a specific <DCS> are not referred from the shared DCS schema files.

Note that event payload schemas are only referred by their respective event schema.

_The Fragment Part_

By OAS 3.0, the fragment part should be interpreted as a https://datatracker.ietf.org/doc/html/rfc6901[JSON Pointer], beginning with a "/" and pointing through the JSON tree structure of the referred JSON Schema file. With the above defined structure of the schema files, the fragment part fits the pattern

`/definitions/<Entity>`

==== *Generating an OAS file*

* Using the Web UI from when the Cloudspace first spun-up, or if you don't have this available any more, see the end of section 3.1 [TODO: X-Ref]. This tab will present you with a simple Web UI with a drop-down list of APIs, one for every directory under `OAS_Open_API_And_Data_Model/apis`. Use this to find your API in the drop down list:


=== User Guide Deep Dive

* Structure and Template
* Cover Page: Title, Version, Date, Status
* Examples
* Auxillary Diagrams (Lifecycles)

=== Conformance Profile Deep Dive

* Initial Generation
* How to read the file
* How to craft a custom rule

=== Troubleshooting

* Codespace "Express" WebUI
** Stops working
** Generation problems: Looking at the underlying "log.log" file?
** How to run the OAS and user-guide generation without the Express UI?
* Examples are not currently validated against the OAS file

=== Governance Checklists

A table of quick visual tests on the details of the rules file and user guide
As people often start a new rules file with a copy-n-paste from a previous existing file - it is easy for "working errors" to permiate unnoticed.

* API Name: ("Management" convention?)
* API Version: Following SemVer.org
* API Description: Short/Concise: Avoid formatting and non-ASCII characters
* Basepath/Server.URL: Do not use 'basePath' in the rules file - even though it is commonly copy-n-pasted from v4 rules files. It will not reflect in the OAS file.

Schema files

* Use of $ref: /definitions
* Attribute descriptions: Be careful in Common/ to be 'generic'


== Administrative Appendix

This Appendix provides additional background material about the TM Forum
and this document. In general, sections may be included or omitted as
desired, however a Document History must always be included.

=== Document History

==== Version History

This section records the changes between this and the previous document
version as it is edited by the team concerned. Note: this is an
incremental number which does not have to match the release number and
used for change control purposes only.

[options=header]
|===
|Version Number |Date Modified |Modified by | Description of changes

|0.1.0 |18-Mar-2024 | Stephen Harrop |First layout of the basics
|0.2.0 |17-Apr-2025 | Lutz Bettge |Schema Repository, details of Schema File, Reference Format 

|===

=== Acknowledgments

This document was prepared by the members of the TM Forum API team:

* Stephen Harrop, Vodafone, Editor
* Revathi Sivaji, TM Forum, Contributor
* Heidi Lobecker, TM Forum, Contributor
* Uche Uba, TM Forum, Contributor
* Lutz Bettge, Deutsche Telekom, Contributor
* Olivier Arnaud, Orange, Contributor
